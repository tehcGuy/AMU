? znaczy, że rózni się od odpowiedzi Moskowietsa
useful
https://www.baeldung.com/cs/heap-vs-binary-search-tree


1. Given a stack S containing some numbers, write an algorithm that first move all non-negative elements from S to queue Q1, and all negative numbers to queue Q2. Write the array implementation of used operations on stacks and queues. You can omit checking for overflows and underflows.
// array implementation is the regular implementation of those data structures
// do not forget to include the implementation of functions

1. Solution

	function STACK_EMPTY(S)
		if S.top == 0
		then return true
		else return false


	procedure TRANSFER(S, S.top)
	
	Q1.head == 1
	Q1.tail == 1
	
	Q2.head == 1
	Q2.tail == 1
	
		while not (STACK_EMPTY(S)) do
			x = POP(S)
			if x > 0 then
				ENQUEUE(Q1, x)
			if x < 0 then
				ENQUEUE(Q2, x)
				
2. Given a single linked list L whose nodes have integer keys, write an algorithm that computes the number of nodes in L, where keys are even numbers

	function AMOUNT_NODES(L)
		if L.head == NIL
			write "Blad"
			return -1
		counter = 0
		x = L.head
		while x <> NIL do
			if x.key mod 2 == 0 then
				counter = counter + 1
			x = x.next
			
		return counter

?3. Given a min-heap A, write an algorithm which sets the value in the root of A to 3 and restores the min heap property in A. Write the implementation of used operations on a min heap


//переглянути значення функції, чи вона ходить по всьому дереву

	MIN_HEAPIFY (A, i)
		left = 2*i
		right = 2*i + 1
	if (left <= A.heap-size) and (A[left] < A[i])
		then smallest = left
	else smallest = i
	if (right <= A.heap-size) and (A[right] < A[smallest])
		then smallest = right
	if smallest <> i
		then A[i] <-> A[smallest]
	MIN_HEAPIFY(A, smallest)
	return


	procedure ADD_AND_RESTORE(A)
	if A.heap-size < 1
		then write "Kopiec pusty"
		return -1
		
	A[1] = 3
	MIN_HEAPIFY(A, 1)

4. Given a binary tree T, write an algorithm that computes numbers of its nodes having the right child only
his code:

function ZNALEZ(T)
	liczylnyk = 0
	return count(T, liczylnyk)


function count(T, temp)
	x = T.root
	
	if x <> NIL then 
		if (x.left == NIL) and (x.right <> NIL) then
			temp = temp + 1
		count(x.left, temp)
		count(x.right, temp)
	return temp
	

4.1 Given a binary tree T, write an algorithm that computes numbers of its nodes having either the right child or left child (it is not important)

function ZNALEZ(T)
	liczylnyk = 0
	return count(T, liczylnyk)


function function count(T, temp)
while x <> NIL do
	function count(x.left, temp)
if (x.left <> NIL and x.right == NIL) or    (x.left == NIL and x.right <> NIL)
	then licznik = licznik + 1

function count(x.right, temp)

return temp

		
5. Given a BST T having at least two nodes, write an algorithm that returns the second smallest key stored at T. Assume that all keys stored at T are pairwise different. Write the implementation of used operations on a BST

//po czwić znalezenia nastepnika
function 2ND_MIN(T)
	x = T.root
	while x.left <> NIL
		do x = x.left
	return x.parent.key

6. Consider hash tables H of size m = 7 and the sequence of the keys (8,1,12,3,5)
	a. illustrate the insertion of these keys into H with function h(k) = k mod 7 and collision resolved by chaining 
	b. Illustrate the insertion of these keys into H using double hashing with auxiliary hash funcitions h_1(k)= k and  h_2(k)= 1 + (k mod 6)	
		
LOOK at your copybook for answers or explanation
